
# 设计模式六大规则

## 单一职责原则
描述的意思是每个类都只负责单一的功能，切不可太多，并且一个类应当尽量的把一个功能做到极致。

## 里氏替换原则
这个原则表达的意思是一个子类应该可以替换掉父类并且可以正常工作。

## 接口隔离原则
也称接口最小化原则，强调的是一个接口拥有的行为应该尽可能的小。

## 依赖倒置原则
这个原则描述的是高层模块不该依赖于低层模块，二者都应该依赖于抽象，抽象不应该依赖于细节，细节应该依赖于抽象。

## 迪米特原则
也称最小知道原则，即一个类应该尽量不要知道其他类太多的东西，不要和陌生的类有太多接触。

## 开-闭原则
对修改关闭，对扩展开放。








# 创建型设计模式
## 简单工厂模式（Simple Factory）

简单工厂模式又叫做静态工厂方法模式是由一个工厂对象决定创建出哪一种产品类的实例。

- **设计原则**：遵循单一职责、违背开闭原则
- **常用场景**：需要在一堆产品中选择其中一个产品
- **选择关键点**：一种产品是否可根据某个参数决定它的种类
- **相关设计模式**工厂方法模式：工厂方法模式是简单工厂模式的进一步抽象化，在这两者之间做选择，主要看将工厂进一步抽象化是否有必要，通常情况下，如果工厂的作用仅仅是用来制造产品，则没必要使用工厂方法模式。

## 工厂方法模式（Factory Method）

工厂方法模式的用意是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。

- **设计原则**：遵循单一职责、依赖倒置、开闭原则
- **常用场景**：一种场景是希望工厂与产品的种类对客户端保持透明，给客户端提供一致的操作，另外一种是不同的工厂和产品可以提供客户端不同的服务或功能
- **选择关键点**：工厂类和产品类是否是同生同灭的关系
- **相关设计模式**抽象工厂模式：工厂方法模式与抽象工厂模式最大的区别在于，在工厂方法模式中，工厂创造的是一个产品，而在抽象工厂模式中，工厂创造的是一个产品族。

##抽象工厂模式（Abstract Factory）

抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

- **设计原则**：遵循单一职责、依赖倒置、开闭原则
- **常用场景**：需要一个接口可以提供一个产品族，且不必知道产品的具体种类
- **选择关键点**：产品族是否需要一起提供，且是否有一致的接口
- **相关设计模式**建造者模式：两者都是建造一批对象或者说产品，不同的是两者的目的和实现手段，在建造者模式中，是为了复用对象的构建过程而定义了一个指挥者，而在抽象工厂模式中，是为了提供一个这批对象的创建接口而定义了抽象工厂接口。




## 建造者模式（Builder）

建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示

- **设计原则**：遵循单一职责、开闭原则
- **常用场景**：需要构建一批构建过程相同但表示不同的产品，而构建过程非常复杂
- **选择关键点**：各个产品的构建过程是否相同



## 原型模式（Prototype）

原型模式用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象

- **设计原则**：无
- **常用场景**：需要在运行时动态的创建指定实例种类的对象，或是需要复用其状态
- **选择关键点**：创建出来的对象是否可以立即投入使用





# **结构型设计模式**



## 代理模式（Proxy）

代理模式是对象的结构模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。

- **设计原则**：体现功能复用
- **常用场景**：需要修改或屏蔽某一个或若干个类的部分功能，复用另外一部分功能，可使用静态代理，若是需要拦截一批类中的某些方法，在方法的前后插入一些一致的操作，假设这些类有一致的接口，可使用JDK的动态代理，否则可使用cglib
- **选择关键点**：静态代理选择的关键点是是否要复用被代理的部分功能，动态代理选择的关键点在于能否在将被代理的这一批类当中，找出相同的切入点
- **相关设计模式**适配器模式：对于适配器模式当中的定制适配器，它与静态代理有着相似的部分，二者都有复用功能的作用，不同的是，静态代理会修改一部分原有的功能，而适配器往往是全部复用，而且在复用的同时，适配器还会将复用的类适配一个接口



## 适配器模式（Adapter）

适配器模式将一个类的接口转换成客户希望的另外一个接口。

- **设计原则**：遵循开闭原则、体现功能复用
- **常用场景**：需要使用一个类的功能，但是该类的接口不符合使用场合要求的接口，可使用定制适配器，又或者是有一个接口定义的行为过多，则可以定义一个缺省适配器，让子类选择性的覆盖适配器的方法
- **选择关键点**：定制适配器的选择关键点在于是否有更加优良的替代方案，缺省适配器的选择关键点在于接口中的方法是否可以不全部提供，且都有缺省方案
- **相关设计模式**装饰器模式：对于适配器模式中的定制适配器与装饰器模式，二者都是使用组合加继承的手段，不同的是，适配器模式的目的在于适配接口，装饰器模式的目的在于动态的添加功能，且可以叠加。



## 装饰模式（Decorator）

装饰模式又名包装(Wrapper)模式。装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。

- **设计原则**：遵循迪米特、单一职责、开闭原则，破坏里氏替换，体现功能复用
- **常用场景**：一个类需要动态的添加功能，且这些功能可以相互叠加
- **选择关键点**：添加的功能是否需要动态组装









## 策略模式（Strategy）
策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。





## 模板方法模式（Template Method）
准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。


